# Autogenerated using ProtoBuf.jl v1.1.0 on 2025-03-17T18:13:24.211
# original file: /Users/anshul/.julia/dev/geo/MapTiles.jl/src/protobuf/2.1/vector_tile.proto (proto2 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"Tile.Value", var"Tile.GeomType", var"Tile.Feature", var"Tile.Layer", Tile


struct var"Tile.Value"
    string_value::String
    float_value::Float32
    double_value::Float64
    int_value::Int64
    uint_value::UInt64
    sint_value::Int64
    bool_value::Bool
end
PB.extendable_field_numbers(::Type{var"Tile.Value"}) = Union{Int,UnitRange{Int}}[8:536870911]
PB.default_values(::Type{var"Tile.Value"}) = (;string_value = "", float_value = zero(Float32), double_value = zero(Float64), int_value = zero(Int64), uint_value = zero(UInt64), sint_value = zero(Int64), bool_value = false)
PB.field_numbers(::Type{var"Tile.Value"}) = (;string_value = 1, float_value = 2, double_value = 3, int_value = 4, uint_value = 5, sint_value = 6, bool_value = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Tile.Value"})
    string_value = ""
    float_value = zero(Float32)
    double_value = zero(Float64)
    int_value = zero(Int64)
    uint_value = zero(UInt64)
    sint_value = zero(Int64)
    bool_value = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            string_value = PB.decode(d, String)
        elseif field_number == 2
            float_value = PB.decode(d, Float32)
        elseif field_number == 3
            double_value = PB.decode(d, Float64)
        elseif field_number == 4
            int_value = PB.decode(d, Int64)
        elseif field_number == 5
            uint_value = PB.decode(d, UInt64)
        elseif field_number == 6
            sint_value = PB.decode(d, Int64, Val{:zigzag})
        elseif field_number == 7
            bool_value = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Tile.Value"(string_value, float_value, double_value, int_value, uint_value, sint_value, bool_value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Tile.Value")
    initpos = position(e.io)
    !isempty(x.string_value) && PB.encode(e, 1, x.string_value)
    x.float_value != zero(Float32) && PB.encode(e, 2, x.float_value)
    x.double_value != zero(Float64) && PB.encode(e, 3, x.double_value)
    x.int_value != zero(Int64) && PB.encode(e, 4, x.int_value)
    x.uint_value != zero(UInt64) && PB.encode(e, 5, x.uint_value)
    x.sint_value != zero(Int64) && PB.encode(e, 6, x.sint_value, Val{:zigzag})
    x.bool_value != false && PB.encode(e, 7, x.bool_value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Tile.Value")
    encoded_size = 0
    !isempty(x.string_value) && (encoded_size += PB._encoded_size(x.string_value, 1))
    x.float_value != zero(Float32) && (encoded_size += PB._encoded_size(x.float_value, 2))
    x.double_value != zero(Float64) && (encoded_size += PB._encoded_size(x.double_value, 3))
    x.int_value != zero(Int64) && (encoded_size += PB._encoded_size(x.int_value, 4))
    x.uint_value != zero(UInt64) && (encoded_size += PB._encoded_size(x.uint_value, 5))
    x.sint_value != zero(Int64) && (encoded_size += PB._encoded_size(x.sint_value, 6, Val{:zigzag}))
    x.bool_value != false && (encoded_size += PB._encoded_size(x.bool_value, 7))
    return encoded_size
end

@enumx var"Tile.GeomType" UNKNOWN=0 POINT=1 LINESTRING=2 POLYGON=3

struct var"Tile.Feature"
    id::UInt64
    tags::Vector{UInt32}
    var"#type"::var"Tile.GeomType".T
    geometry::Vector{UInt32}
end
PB.default_values(::Type{var"Tile.Feature"}) = (;id = UInt64(0x0000000000000000), tags = Vector{UInt32}(), var"#type" = var"Tile.GeomType".UNKNOWN, geometry = Vector{UInt32}())
PB.field_numbers(::Type{var"Tile.Feature"}) = (;id = 1, tags = 2, var"#type" = 3, geometry = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Tile.Feature"})
    id = UInt64(0x0000000000000000)
    tags = PB.BufferedVector{UInt32}()
    var"#type" = var"Tile.GeomType".UNKNOWN
    geometry = PB.BufferedVector{UInt32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, UInt64)
        elseif field_number == 2
            PB.decode!(d, wire_type, tags)
        elseif field_number == 3
            var"#type" = PB.decode(d, var"Tile.GeomType".T)
        elseif field_number == 4
            PB.decode!(d, wire_type, geometry)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Tile.Feature"(id, tags[], var"#type", geometry[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Tile.Feature")
    initpos = position(e.io)
    x.id != UInt64(0x0000000000000000) && PB.encode(e, 1, x.id)
    !isempty(x.tags) && PB.encode(e, 2, x.tags)
    x.var"#type" != var"Tile.GeomType".UNKNOWN && PB.encode(e, 3, x.var"#type")
    !isempty(x.geometry) && PB.encode(e, 4, x.geometry)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Tile.Feature")
    encoded_size = 0
    x.id != UInt64(0x0000000000000000) && (encoded_size += PB._encoded_size(x.id, 1))
    !isempty(x.tags) && (encoded_size += PB._encoded_size(x.tags, 2))
    x.var"#type" != var"Tile.GeomType".UNKNOWN && (encoded_size += PB._encoded_size(x.var"#type", 3))
    !isempty(x.geometry) && (encoded_size += PB._encoded_size(x.geometry, 4))
    return encoded_size
end

struct var"Tile.Layer"
    version::UInt32
    name::String
    features::Vector{var"Tile.Feature"}
    keys::Vector{String}
    values::Vector{var"Tile.Value"}
    extent::UInt32
end
PB.extendable_field_numbers(::Type{var"Tile.Layer"}) = Union{Int,UnitRange{Int}}[16:536870911]
PB.default_values(::Type{var"Tile.Layer"}) = (;version = UInt32(0x00000001), name = "", features = Vector{var"Tile.Feature"}(), keys = Vector{String}(), values = Vector{var"Tile.Value"}(), extent = UInt32(0x00001000))
PB.field_numbers(::Type{var"Tile.Layer"}) = (;version = 15, name = 1, features = 2, keys = 3, values = 4, extent = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Tile.Layer"})
    version = UInt32(0x00000001)
    name = ""
    features = PB.BufferedVector{var"Tile.Feature"}()
    keys = PB.BufferedVector{String}()
    values = PB.BufferedVector{var"Tile.Value"}()
    extent = UInt32(0x00001000)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 15
            version = PB.decode(d, UInt32)
        elseif field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, features)
        elseif field_number == 3
            PB.decode!(d, keys)
        elseif field_number == 4
            PB.decode!(d, values)
        elseif field_number == 5
            extent = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Tile.Layer"(version, name, features[], keys[], values[], extent)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Tile.Layer")
    initpos = position(e.io)
    x.version != UInt32(0x00000001) && PB.encode(e, 15, x.version)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.features) && PB.encode(e, 2, x.features)
    !isempty(x.keys) && PB.encode(e, 3, x.keys)
    !isempty(x.values) && PB.encode(e, 4, x.values)
    x.extent != UInt32(0x00001000) && PB.encode(e, 5, x.extent)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Tile.Layer")
    encoded_size = 0
    x.version != UInt32(0x00000001) && (encoded_size += PB._encoded_size(x.version, 15))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.features) && (encoded_size += PB._encoded_size(x.features, 2))
    !isempty(x.keys) && (encoded_size += PB._encoded_size(x.keys, 3))
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 4))
    x.extent != UInt32(0x00001000) && (encoded_size += PB._encoded_size(x.extent, 5))
    return encoded_size
end

struct Tile
    layers::Vector{var"Tile.Layer"}
end
PB.extendable_field_numbers(::Type{Tile}) = Union{Int,UnitRange{Int}}[16:8191]
PB.default_values(::Type{Tile}) = (;layers = Vector{var"Tile.Layer"}())
PB.field_numbers(::Type{Tile}) = (;layers = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Tile})
    layers = PB.BufferedVector{var"Tile.Layer"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 3
            PB.decode!(d, layers)
        else
            PB.skip(d, wire_type)
        end
    end
    return Tile(layers[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Tile)
    initpos = position(e.io)
    !isempty(x.layers) && PB.encode(e, 3, x.layers)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Tile)
    encoded_size = 0
    !isempty(x.layers) && (encoded_size += PB._encoded_size(x.layers, 3))
    return encoded_size
end
